This is Japanese version of "readme.txt".

Рхет（ラテン文字表記でRkhjet、発音は「ルヒェ（ッ）ト」的な感じで、厳密にはIPAで[rçet]）とは「ぬこ」氏の作ったプログラミング言語「Pxem」から派生したプログラミング言語です。

==名前の由来==
「Рхет」という名前は、派生元のプログラミング言語「Pxem」をキリル文字として読んだとき、どんな風に読めるかというのが由来です。フォントによっては「Рхет」の「т」がラテン文字の「T」に見えるかもしれませんが、「т」という文字は立体がラテン文字の「T」に、斜体がラテン文字の「m」に見えます。

また、開発段階ではとあるコミュニティにおいて「言語名をどうしたほうが良いか」と相談したことがあり、一番気に入った回答が「Qyfn」で、これは「Pxem」という名前の文字全てを一文字ずらしてできる名前でした。

しかし、それだと「Pxem派生言語だということがわかりづらい」「ファイルの拡張子が必然的に.qyfや.qyfnとなるのだが.qに命令はない」ということで、結局ボツにしました。また「Pxem誕生から10年後、2018年に新しく作る」ということで「Pxem18」というのも考えたことがありましたがやめました。

==仕様==
派生元言語「Pxem」には、int型のスタックと一時領域が用意されています。しかし、「Рхет」では、一時領域を廃止する代わりにスタックを2つ用意することにしました。片方をメイン、もう片方をサブにします。

「Pxem」の大きな特徴は、「ファイルの中身だけでなく、ファイル名もソースコード扱い」という点です。これにより、「ゼロバイトプログラミング」なるものができます。ファイル名に「ファイルの中身を見る」命令がなければファイルの中身はなかったことにされます。「Рхет」も同様になりますが、一部の仕様を異ならせることにします。詳しくは後述します。

また、「Рхет」ではファイルの拡張子は「.pxer」か「.rrkh」になります。

===派生元言語「Pxem」との相違点===
1.ファイルの拡張子をどうするかにより挙動が変わります。「Pxem」ではただ単にファイル名を「Hello, world!.pxe」とするだけで「Hello, world!」と出力されます。「Рхет」でも、同様にファイル名を「Hello, world!.pxer」とするだけで大丈夫です。一方でファイル名が「Hello, world!.rrkh」ならば挙動は変わります（詳しくは後述）。
2.「Pxem」では命令文字列の大文字と小文字の区別がされませんでしたが、「Рхет」では区別することにします。
3.様々な命令を追加しました。
4.既存の命令を一部拡張しました。大文字か小文字かで区別されます。
5.「Pxem」では、「ファイルの中身をコードとして実行する」命令をファイル内で実行した際、ファイルの中身に改行があろうがなかろうが関係ありませんでしたが、「Рхет」では行番号を区別します。

===動作===
「Рхет」のインタプリタは、まず最初にファイル名を先頭から順に一文字ずつ読みます。このとき、命令文字列以外は全て文字という「データ」扱いとなります。命令文字列に達すると、それまでに読まれた文字がメインスタックに積まれます。例えば、

	Hello, world!.pxer

というファイルでは、「Hello, world!」が文字列で、「.p」と「.r」が命令文字列です。その後の「hj」も一応、文字列ですが、格納される前に処理が終了します。インタプリタがファイル名を最後まで読み終えるか、または実行を終了する命令が実行されると、実行が終了します。

それから、例えば

	Hello, world!.rrkh

のように、ファイル名に拡張子のうちの「.r」以外の命令がなければファイルの中身の一行目が実行されます。

基本的には、ファイル名がメイン関数となり、ファイルの中身の内、一行一行が関数に該当します。ファイル名に拡張子部分の.r以外の命令がなければファイルの中身の一行目がメイン関数になります。

例えば、ファイル名が

	Hello, world!.rhj

で、ファイルの中身が

	Hello,.e
	.p!dlror .v.p

ならば、この場合はメイン関数が「Hello,.e」、第二関数が「.p!dlror .v.p」となります。

===命令文字列===
ここで、単語を定義します。

スタックをポップ
	スタックの先頭にある値を取り出すことです。その値はスタックからなくなります。
	尚、これを行う命令を実行する際、スタック内のデータの数が足りなければ命令の内容が「何もしない」に等価となります（一部、特筆される場合を除く）。

スタックにプッシュ
	スタックの先頭に値を追加することです。

また、単に「スタックをポップ」「スタックにプッシュ」と記載されていれば、それはメインスタックに対する操作のことです。

====既存で変更のない命令====
.p
	スタックが空になるまでポップし、文字として出力します。スタックが空になるまで.oを繰り返すのと同じです。

.o
	スタックをポップします。ポップされた値は文字として出力されます。

.n
	スタックをポップします。ポップされた値は文字として出力されます。

.i
	ユーザーからの入力を受け付けます。入力すべき値は文字一つで、その値がスタックにプッシュされます。

._
	ユーザーからの入力を受け付けます。入力すべき値はint型一つで、その値がスタックにプッシュされます。

.c
	スタックをポップし、ポップされた値を2つにしてスタックにプッシュします。
	例えばスタックの中に先頭からx,yがあるときにこの命令が実行されるとスタックの中身はx,x,yとなります。

.s
	スタックをポップします。ポップされた値は単に捨てられます。

.v
	スタックの中身を逆順にします。例えばx,y,zがz,y,xになります。
	この命令を頻繁に実行することは推奨されていないようです。

.f
	ファイルの中身を文字列としてスタックにプッシュします。ファイルの中身は何度でも用いることができます。

.r
	スタックをポップし、0以上ポップされた値未満の乱数を発生させ、発生された値をプッシュします。

.w
	スタックをポップし、ポップされた値が0ならば対応する.aや.Aの次の文字から処理を続けます。
	スタックの中身が空の場合も、同様です。
	ネスト可能です。

.x
	スタックを2回ポップし、最初にポップされた値が次にポップされた値より小さくなければ対応する.aや.Aの次の文字から処理を続けます。
	スタックの中に入っているデータが1個以下の場合も同様です。なお、内部のデータは失われません。
	ネスト可能です。

.y
	スタックを2回ポップし、最初にポップされた値が次にポップされた値より大きくなければ対応する.aや.Aの次の文字から処理を続けます。
	スタックの中に入っているデータが1個以下の場合も同様です。なお、内部のデータは失われません。
	ネスト可能です。

.z
	スタックを2回ポップし、最初にポップされた値と次にポップされた値が等しければ対応する.aや.Aの次の文字から処理を続けます。
	スタックの中に入っているデータが1個以下の場合も同様です。なお、内部のデータは失われません。
	ネスト可能です。

.a
	対応する.w、.x、.y、.z、.W、.X、.Y、.Zから処理を続けます。

.d
	この命令がある場所がメイン関数内ならプログラムの処理が終了します。それ以外ならば現在いる関数の処理を終了しその関数の呼び出し元に戻ります。

.+
	スタックを2回ポップし、ポップされた値の和をプッシュします。
	スタックの中のデータが2個未満ならば演算もポップもされません。

.-
	スタックを2回ポップし、大きい値から小さい値を引いた値をプッシュします。
	スタックの中のデータが2個未満ならば演算もポップもされません。

.!
	スタックを2回ポップし、ポップされた値の積をプッシュします。
	スタックの中のデータが2個未満ならば演算もポップもされません。

====既存だが実行内容が変わった命令====
.e
	この命令がメイン関数にある場合は第二関数を、第二関数ならば第三関数を呼び出し、その関数を処理します。最後の関数にある場合はその関数を再帰呼び出しします。
	この命令を実行する際、新しく2つのスタックが作られ、それぞれのメインスタックとサブスタックの内容がコピーされます。コピーされた命令は呼び出し先の関数で用いられます。
	また、呼び出し先の関数の処理が終わるとその時点での呼び出し元の関数にある2つのスタックは開放され、その時の内容は後ろから順に元のスタックにプッシュされます。
	例えばもともとa,b,cの順にデータが入っているスタックがあったとします。新しく作られたスタックの内容がd,e,fとなりその時点で呼び出された関数の処理が終わると、もともとのスタックの内容がd,e,f,a,b,cとなります。

.t
	メインスタックをポップし、ポップされた値をサブスタックにプッシュします。

.m
	サブスタックをポップし、ポップされた値をメインスタックにプッシュします。

.$
	スタックを2回ポップし、大きい値を小さい値で割った商をプッシュします。尚、ポップされた値の内、1つでも0ならばエラーになります。
	スタックの中のデータが2個未満ならば演算もポップもされません。

.%
	スタックを2回ポップし、大きい値を小さい値で割った余りをプッシュします。尚、ポップされた値の内、1つでも0ならばエラーになります。
	スタックの中のデータが2個未満ならば演算もポップもされません。

====新しい命令====
.P
	.pと同じですが、改行文字が最後に出力されます。スタックが空の場合、改行だけが出力されます。

.O
	.oと同じですが、改行文字も出力されます。スタックが空の場合、改行だけが出力されます。

.N
	.nと同じですが、改行文字も出力されます。スタックが空の場合、改行だけが出力されます。

.E
	.eと違い、関数内の処理が終わると新しいスタックは破棄されます。

.W
	.wと違い、スタックが空ならばこの命令から対応する.aや.Aまでの部分の処理がされます。

.X
	.xと違い、スタック内のデータの数が2未満ならばこの命令から対応する.aや.Aまでの部分の処理がされます。

.Y
	.yと違い、スタック内のデータの数が2未満ならばこの命令から対応する.aや.Aまでの部分の処理がされます。

.Z
	.zと違い、スタック内のデータの数が2未満ならばこの命令から対応する.aや.Aまでの部分の処理がされます。

.A
	.aと違い、対応する.w,.x,.y,.z,.W,.X,.Y,.Zには戻りません。

.D
	.dと違い、どの関数で実行してもプログラム全体の処理を強制終了します。

.L
	先頭と先頭から二番目のデータが入れ替えられます。例えばx,y,z,wの順にスタックに格納されている状態でこの命令が実行されるとy,x,z,wとなります。この命令は言語をチューリング完全にするためのものです。

.G
	現在スタックの中にデータがいくつ入っているのかという数値がプッシュされます。

.J
	メインスタックとサブスタックが入れ替わります。

.H
	数値「-1」がプッシュされます。

===その他===
*負の値がスタックに入っている状態で.pや.P、または負の値がスタックの先頭にある状態で.o、.n、.O、.Nを実行しようとするとエラーが発生します。
**.pや.Pは出力中にエラーを吐きます。
*.w,.x,.y,.z,.W,.X,.Y,.Zを実行する際、対応する.aや.Aが見つからなければエラーになります。.aも同様です。
*インタプリタはファイルのパス名の内、ディレクトリ部分を解釈することはできません。

==最後に==
*「Рхет」の開発者は「TpaeFawzen」です。不具合がございましたらGitHubにてお知らせください。
*このテキストファイルの最終更新バージョンは0.0.1です。
*この言語、及びインタプリタのライセンスは「LICENSE」というファイルを参照してください。
